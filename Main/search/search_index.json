{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SmallRye Config","text":"<p>SmallRye Config is a library that provides a way to configure applications, frameworks and containers. It is used  in applications servers like WildFly, Open Liberty and  TomEE or frameworks like Quarkus. It can also be used completely  standalone in any Java application, which makes it a very flexible library. </p> <p>It follows the MicroProfile Config specification to provide  the initial config foundations and expands with it own concepts to cover a wide range of use cases observed in the  configuration space.   </p>"},{"location":"#use-smallrye-config-in-a-java-application","title":"Use SmallRye Config in a Java application","text":"<p>Add the dependency to your project using your preferred build tool:</p> MavenGradle (Groovy)Gradle (Kotlin)JBang <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.config&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-config&lt;/artifactId&gt;\n    &lt;version&gt;3.13.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation 'io.smallrye.config:smallrye-config:3.13.2-SNAPSHOT'\n</code></pre> <pre><code>implementation(\"io.smallrye.config:smallrye-config:3.13.2-SNAPSHOT\")\n</code></pre> <pre><code>//DEPS io.smallrye.config:smallrye-config:3.13.2-SNAPSHOT\n</code></pre> <p>And retrieve a <code>SmallRyeConfig</code> instance with:</p> <pre><code>SmallRyeConfig config = ConfigProvider.getConfig().unwrap(SmallRyeConfig.class);\n</code></pre> <p>Info</p> <p>The <code>SmallRyeConfig</code> instance will be created and registered to the context class loader if no such configuration  is already created and registered. </p> <p>Or build your own:</p> <pre><code>SmallRyeConfig config = new SmallRyeConfigBuilder().build();\n</code></pre> <p>Info</p> <p><code>SmallRyeConfig</code> is the entry point to all the config capabilities provided by SmallRye Config. </p>"},{"location":"config/config-value/","title":"Config Value","text":"<p>The <code>io.smallrye.config.ConfigValue</code> is a metadata object that holds additional information after the lookup of a  configuration property. It is able to hold information of configuration property name, value, profile, the  <code>ConfigSource</code> from where the configuration was loaded, the ordinal of the <code>ConfigSource</code> and a line number from where  the configuration was loaded if exists.</p>"},{"location":"config/configuration/","title":"Configuration Reference","text":"Configuration Property Type Default <code>smallrye.config.profile</code>The main Profile to activate. String[] <code>smallrye.config.profile.parent</code>The parent Profile to activate. String <code>smallrye.config.locations</code>Additional config locations to be loaded with the Config. The configuration supports multiple locations separated by a comma and each must represent a valid <code>java.net.URI</code>. URI[] <code>smallrye.config.mapping.validate-unknown</code>Validates that a <code>@ConfigMapping</code> maps every available configuration name contained in the mapping prefix. boolean false <code>smallrye.config.secret-handlers</code>The names of the secret handlers to be loaded. A value of <code>all</code> loads all available secret handlers and a value of <code>none</code> skips the load. String[] all <code>smallrye.config.log.values</code>Enable logging of configuration values lookup in DEBUG log level. boolean false"},{"location":"config/customizer/","title":"Customizer","text":"<p>A <code>SmallRyeConfigBuilderCustomizer</code> allows to customize a <code>SmallRyeConfigBuilder</code>, used to create the <code>SmallRyeConfig</code>  instance.</p> <p>Registration of a <code>SmallRyeConfigBuilderCustomizer</code> is done via the <code>ServiceLoader</code> mechanism by providing the implementation classes in a <code>META-INF/services/io.smallrye.config.SmallRyeConfigBuilderCustomizer</code> file. Alternatively,  customizers may be registered via the Programmatic API in <code>SmallRyeConfigBuilder#withCustomizers</code>.</p> <p>The <code>SmallRyeConfigBuilderCustomizer</code> may also assign a priority by overriding the default method <code>int priority()</code>. Customizers are sorted by ascending priority and  executed in that order, meaning that higher numeric priorities will execute last, possible overriding values set by  previous customizers.</p> CustomConfigBuilder<pre><code>package org.acme.config;\n\nimport io.smallrye.config.SmallRyeConfigBuilder;\nimport io.smallrye.config.SmallRyeConfigBuilderCustomizer;\n\npublic class CustomConfigBuilder implements SmallRyeConfigBuilderCustomizer {\n    @Override\n    public void configBuilder(final SmallRyeConfigBuilder builder) {\n        builder.withDefaultValue(\"my.default\", \"1234\");\n    }\n}\n</code></pre> <p>And registration in:</p> META-INF/services/io.smallrye.config.SmallRyeConfigBuilderCustomizer<pre><code>org.acme.config.CustomConfigBuilder\n</code></pre> <p>The <code>CustomConfigBuilder</code> will be executed when creating a new <code>SmallRyeConfig</code> from a <code>SmallRyeConfigBuilder</code>:</p> <pre><code>SmallRyeConfig config = new SmallRyeConfigBuilder().build();\nconfig.getValue(\"my.default\", int.class);\n</code></pre> <p>A look up to <code>my.default</code> returns the value <code>1234</code>, registered by the <code>CustomConfigBuilder</code>.</p>"},{"location":"config/environment-variables/","title":"Environment Variables","text":"<p>Environment Variable names follow the conversion rules specified by MicroProfile Config.</p> <p>SmallRye Config specifies additional conversion rules:</p> <ul> <li>A property with double quotes <code>foo.\"bar\".baz</code>, replace each character that is neither alphanumeric nor <code>_</code>  with <code>_</code>: <code>FOO__BAR__BAZ</code></li> <li>A property with dashes <code>foo.bar-baz</code>, replace each character that is neither alphanumeric nor <code>_</code>   with <code>_</code>: <code>FOO_BAR_BAZ</code></li> <li>An indexed property <code>foo.bar[0]</code> or <code>foo.bar[0].baz</code>, replace each character that is neither alphanumeric nor <code>_</code>   with <code>_</code>: <code>FOO_BAR_0_</code> or <code>FOO_BAR_0__BAZ</code>.</li> </ul> <p>Danger</p> <p>Environment Variables format cannot represent the entire spectrum of common property names.</p> <p>The lookup of configuration values from Environment Variables will always use the dotted format name. For  instance, the lookup of the Environment Variable <code>FOO_BAR</code> value, requires the property name <code>foo.bar</code>:</p> <pre><code>ConfigProvider.getConfig().getValue(\"foo.bar\", String.class);\n</code></pre> <p>When SmallRyeConfig performs the lookup on the Environment Variables Config Source, it applies the conversion rules to  find the matching property name and retrieve the value. </p> <p>In some situations, looking up the exact property name is impossible. For instance, when SmallRye Config has to look up  a configuration that is part of a <code>Map</code>, and the property name contains a dynamic segment (a <code>Map</code> key). In this case,  SmallRye Config relies upon each source\u2019s list of property names. These must be converted back to their most likely  dotted format for Environment Variables.</p> <p>By default, the underscore <code>_</code> of an Environment Variable name always maps to a dot <code>.</code>. If the property name contains a dash or some other special character, that property name can be specified in another Config  Source, with the expected dotted format. It will provide additional information to SmallRye Config to perform a  two-way conversion and match the property names.</p> <p>Consider:</p> .env<pre><code>FOO_BAR_BAZ=VALUE\n</code></pre> <p>Will map to <code>foo.bar.baz</code> and value <code>value</code>.</p> <p>If <code>foo.bar-baz</code> is available in any source:</p> .env<pre><code>FOO_BAR_BAZ=VALUE\n</code></pre> application.properties<pre><code>foo.bar-baz=default\n</code></pre> <p>Will map to <code>foo.bar-baz</code> and value <code>value</code>.</p> <p>Note</p> <p>The property name in dotted format needs to exist somewhere to provide this additional information. It can be set in a  low ordinal source, even without value. The Environment Variables source will override the value and map the correct  configuration name.</p>"},{"location":"config/expressions/","title":"Property Expressions","text":"<p>SmallRye Config provides property expressions expansion on configuration values. An expression string is a mix of plain strings and expression segments, which are wrapped by the sequence ${ \u2026 }.</p> <p>For instance, the following configuration properties file:</p> <pre><code>remote.host=smallrye.io\ncallable.url=https://${remote.host}/\n</code></pre> <p>The resolved value of the <code>callable.url</code> property is <code>https://smallrye.io/</code>.</p> <p>Additionally, the Expression Expansion engine supports the following segments:</p> <ul> <li><code>${expression:value}</code> - Provides a default value after the <code>:</code> if the expansion doesn\u2019t find a value.</li> <li><code>${my.prop${compose}}</code> - Composed expressions. Inner expressions are resolved first.</li> <li><code>${my.prop}${my.prop}</code> - Multiple expressions.</li> </ul> <p>If an expression cannot be expanded and no default is supplied a <code>NoSuchElementException</code> is thrown.</p> <p>Expression expansion may be selectively disabled with <code>io.smallrye.config.Expressions</code>:</p> <pre><code>Config config = ConfigProvider.getConfig();\n\nString url = Expressions.withoutExpansion(() -&gt; \n    config.getValue(\"callable.url\", String.class));\n</code></pre>"},{"location":"config/getting-started/","title":"Getting Started","text":""},{"location":"config/getting-started/#config-sources","title":"Config Sources","text":"<p>By default, SmallRye Config reads configuration properties from multiple configuration sources (by descending ordinal):</p> <ol> <li>(<code>400</code>) System properties</li> <li>(<code>300</code>) Environment variables</li> <li>(<code>295</code>) <code>.env</code> file in the current working directory</li> <li>(<code>260</code>) <code>application.properties</code> in <code>config</code> folder, located in the current working directory</li> <li>(<code>250</code>) <code>application.properties</code> in the classpath </li> <li>(<code>100</code>) MicroProfile Config configuration file <code>META-INF/microprofile-config.properties</code> in the classpath</li> </ol> <p>A configuration source is handled by a <code>ConfigSource</code>. A <code>ConfigSource</code> provides configuration values from a specific place.  </p> <p>The final configuration is the aggregation of the properties defined by all these sources. A configuration property  lookup starts by the highest ordinal configuration source available and works it way down to other sources until a  match is found. This means that any configuration property may override a value just by setting a different value in a  higher ordinal config source. For example, a property configured using an Environment Variable overrides the value  provided using the <code>microprofile-config.properties</code> file.</p>"},{"location":"config/getting-started/#system-properties","title":"System Properties","text":"<p>System properties can be handed to the application through the <code>-D</code> flag during startup. For instance,  <code>java -Dmy.prop -jar my.jar</code>.</p>"},{"location":"config/getting-started/#environment-variables","title":"Environment Variables","text":"<p>Environment variables are set directly in the host operating system. Environment variables names follow the conversion  rules detailed by Environment Variables.</p>"},{"location":"config/getting-started/#microprofile-config-configuration-file","title":"MicroProfile Config configuration file","text":"<p>The MicroProfile Config configuration file <code>META-INF/microprofile-config.properties</code> in the classpath. It follows the  standard convention for <code>properties</code> files.</p> META-INF/microprofile-config.properties<pre><code>greeting.message=hello\ngoodbye.message=bye\n</code></pre>"},{"location":"config/getting-started/#additional-config-sources","title":"Additional Config Sources","text":"<p>SmallRye Config provides additional extensions which cover other configuration formats and stores:</p> <ul> <li>YAML</li> <li>File System</li> <li>ZooKeeper</li> <li>HOCON</li> </ul> <p>It is also possible to create a Custom ConfigSource.</p>"},{"location":"config/getting-started/#retrieving-the-configuration","title":"Retrieving the Configuration","text":""},{"location":"config/getting-started/#programmatically","title":"Programmatically","text":"<p>The <code>org.eclipse.microprofile.config.ConfigProvider.getConfig()</code> API allows to access the  <code>org.eclipse.microprofile.config.Config</code> API programmatically.</p> <pre><code>Config config = ConfigProvider.getConfig();\n\nString message = config.getValue(\"greeting.message\", String.class);\n</code></pre> <p>The <code>Config</code> instance will be created and registered to the current context class loader if no such configuration is  already created and registered. This means that subsequent calls to <code>ConfigProvider.getConfig()</code> will return the same  <code>Config</code> instance if the context class loader is the same.</p> <p>To obtain a detached instanced, use the <code>io.smallrye.config.SmallRyeConfigBuilder</code>:</p> <pre><code>SmallRyeConfig config = new SmallRyeConfigBuilder()\n    .addDefaultInterceptors()\n    .addDefaultSources()\n    .build();\n\nString message = config.getValue(\"greeting.message\", String.class);\n</code></pre>"},{"location":"config/getting-started/#with-cdi","title":"With CDI","text":"<p>In a CDI environment, configuration can be injected in CDI aware beans with <code>@Inject</code> and  the <code>org.eclipse.microprofile.config.inject.ConfigProperty</code> qualifier.</p> <pre><code>@Inject\n@ConfigProperty(name = \"greeting.message\") \nString message;\n\n@Inject\n@ConfigProperty(name = \"greeting.suffix\", defaultValue=\"!\") \nString suffix;\n\n@Inject\n@ConfigProperty(name = \"greeting.name\")\nOptional&lt;String&gt; name; \n\n@Inject\nSmallRyeConfig config;\n</code></pre> <ul> <li>If a value if not provided for this <code>greeting.message</code>, the application startup fails with a  <code>jakarta.enterprise.inject.spi.DeploymentException: No config value of type [class java.lang.String] exists for: greeting.message</code>.</li> <li>The default value <code>!</code> is injected if the configuration does not provide a value for <code>greeting.suffix</code>.</li> <li>The property <code>greeting.name</code> is optional - an empty Optional is injected if the configuration does not provide a  value for it.</li> </ul>"},{"location":"config/getting-started/#override-config","title":"Override Config","text":"<p>It is possible to override <code>Config</code> default initialization <code>ConfigProvider.getConfig()</code>, by extending  <code>io.smallrye.config.SmallRyeConfigFactory</code> and registering the implementation with the <code>ServiceLoader</code> mechanism.  </p>"},{"location":"config/getting-started/#config-vs-smallryeconfig","title":"Config vs SmallRyeConfig","text":"<p>The <code>io.smallrye.config.SmallRyeConfig</code> is an implementation of <code>org.eclipse.microprofile.config.Config</code> and provides  additional APIs and helper methods not available in <code>org.eclipse.microprofile.config.Config</code>. To obtain an instance of  <code>io.smallrye.config.SmallRyeConfig</code>, the original <code>org.eclipse.microprofile.config.Config</code> can be unwrapped:</p> <pre><code>Config config = ConfigProvider.getConfig();\nSmallRyeConfig smallRyeConfig = config.unwrap(SmallRyeConfig.class);\n</code></pre> <p>Or if using the builder it can be obtained directly:</p> <pre><code>SmallRyeConfig config = new SmallRyeConfigBuilder().build();\n</code></pre> <p>A few notable APIs provided by <code>io.smallrye.config.SmallRyeConfig</code> allow to:</p> <ul> <li>Retrive multiple values into a specified <code>Collection</code></li> <li>Retrive Indexed Values</li> <li>Retrive Config Mappings instances</li> <li>Retrieve the raw value of a configuration</li> <li>Check if a property is present</li> <li>Retrieve a <code>Converter</code></li> <li>Convert values</li> </ul>"},{"location":"config/getting-started/#converters","title":"Converters","text":"<p>The <code>ConfigSource</code> retrieves a configuration value as a <code>String</code>. Other data types require a conversion using the  <code>org.eclipse.microprofile.config.spi.Converter</code> API.</p> <p>Most of the common <code>Converter</code> types are provided by default:</p> <ul> <li><code>boolean</code> and <code>java.lang.Boolean</code>; the values \u201ctrue\u201d, \u201c1\u201d, \u201cYES\u201d, \u201cY\u201d \u201cON\u201d represent <code>true</code>. Any other value will be  interpreted as <code>false</code></li> <li><code>byte</code> and <code>java.lang.Byte</code></li> <li><code>short</code> and <code>java.lang.Short</code></li> <li><code>int</code>, <code>java.lang.Integer</code>, and <code>java.util.OptionalInt</code></li> <li><code>long</code>, <code>java.lang.Long</code>, and <code>java.util.OptionalLong</code></li> <li><code>float</code> and <code>java.lang.Float</code>; a dot \u2018.\u2019 is used to separate the fractional digits</li> <li><code>double</code>, <code>java.lang.Double</code>, and <code>java.util.OptionalDouble</code>; a dot \u2018.\u2019 is used to separate the fractional digits</li> <li><code>char</code> and <code>java.lang.Character</code></li> <li><code>java.lang.Class</code> based on the result of <code>Class.forName</code></li> <li><code>java.net.InetAddress</code></li> <li><code>java.util.UUID</code></li> <li><code>java.util.Currency</code></li> <li><code>java.util.regex.Pattern</code></li> <li><code>java.nio.file.Path</code></li> <li>Any class with declared static methods <code>of</code>, <code>valueOf</code> or <code>parse</code> that take a <code>String</code> or a <code>CharSequence</code></li> <li>Any class with declared constructors that takes a <code>String</code> or a <code>CharSequence</code> </li> </ul> <p>All default converters have a priority of <code>1</code>.</p>"},{"location":"config/indexed-properties/","title":"Indexed Properties","text":"<p>In MicroProfile Config, a config value with unescaped commas may be  converted to <code>Collection</code>. It works for simple cases, but it becomes cumbersome and limited for more advanced use cases.</p> <p>Indexed Properties provide a way to use indexes in config property names to map specific elements in a <code>Collection</code>  type. Since the indexed element is part of the property name, it can also map complex object types. Consider:</p> <pre><code># MicroProfile Config - Collection Values\nmy.collection=dog,cat,turtle\n\n# SmallRye Config - Indexed Property\nmy.indexed.collection[0]=dog\nmy.indexed.collection[1]=cat\nmy.indexed.collection[2]=turtle\n</code></pre> <p>The indexed property syntax uses the property name and square brackets with an index in between.</p> <p>A call to <code>Config#getValues(\"my.collection\", String.class)</code>, will automatically create and convert a <code>List&lt;String&gt;</code>  that contains the values <code>dog</code>, <code>cat</code> and <code>turtle</code>. A call to <code>Config#getValues(\"my.indexed.collection\", String.class)</code>  returns the exact same result. The indexed property format is prioritized when both styles are found in the same  configuration source. When available in multiple sources, the higher ordinal source wins, like any other configuration  lookup.</p> <p>The indexed property is sorted by its index before being added to the target <code>Collection</code>. Any gaps in the indexes do  not resolve to the target <code>Collection</code>, which means that the <code>Collection</code> result will store all values without empty  elements.</p>"},{"location":"config/map-support/","title":"Map Support","text":"<p>SmallRye Config allows injecting multiple configuration parameters as a <code>Map</code>. The configuration value syntax is  represented by <code>property.name.map-key=value</code> Consider:</p> <pre><code>server.reasons.200=OK\nserver.reasons.201=Created\n</code></pre> <p>The previous configuration could be injected directly in a CDI Bean:</p> <p>With <code>@ConfigProperty</code></p> <pre><code>@ApplicationScoped\npublic class ConfigBean {\n    @Inject\n    @ConfigProperty(name = \"server.reasons\") \n    Map&lt;Integer, String&gt; reasons;\n}\n</code></pre> <p>With <code>@ConfigProperties</code></p> <pre><code>@ConfigProperties(prefix = \"server\") \npublic class Config {\n    Map&lt;Integer, String&gt; reasons; \n}\n</code></pre> <p>The <code>Map</code> will contains the keys <code>200</code> and <code>201</code>, which map to the values <code>OK</code> and <code>Created</code>.</p> <p>Note</p> <p>Only the direct sub properties will be converted into a <code>Map</code> and injected into the target bean, the rest will be ignored. In other words, in the previous example, a property whose name is <code>reasons.200.a</code> would be ignored as not considered as a direct sub property.</p> <p>Note</p> <p>The property will be considered as missing if no direct sub properties could be found.</p> <p>It is also possible to retrieve the <code>Map</code> programmatically by calling the methods  <code>SmallRyeConfig#getValues(\"server.reasons\", Integer.class, String.class)</code> or  <code>SmallRyeConfig#getOptionalValues(\"server.reasons\", Integer.class, String.class)</code>.</p>"},{"location":"config/mappings/","title":"Mappings","text":"<p>With SmallRye Config Mappings, it is possible to group multiple configuration properties in a single interface that  share the same prefix (or namespace). It supports the following set of features:</p> <ul> <li>Automatic conversion of the configuration type, including <code>List</code>, <code>Set</code>, <code>Map</code>, <code>Optional</code> and primitive types.</li> <li>Nested Config Mapping groups.</li> <li>Configuration Properties Naming Strategies</li> <li>Integration with Bean Validation</li> </ul>"},{"location":"config/mappings/#mapping-rules","title":"Mapping Rules","text":"<p>A complex object type uses the following rules to map configuration values to their member values:</p> <ul> <li>A configuration path is built by taking the object type prefix (or namespace) and the mapping member name</li> <li>The member name is converted to its kebab-case format</li> <li>If the member name is represented as a getter, the member name is taken from its property name equivalent, and then   converted to its kebab-case format.</li> <li>The configuration value is automatically converted to the member type</li> <li>The configuration path is required to exist with a valid configuration value or the mapping will fail.</li> </ul> <p>Info</p> <p>Kebab-case - the method name is derived by replacing case changes with a dash to map the configuration property.</p> <p>A Config Mapping requires an interface with minimal metadata configuration annotated with  <code>io.smallrye.config.ConfigMapping</code>:</p> <pre><code>@ConfigMapping(prefix = \"server\")\ninterface Server {\n    String host();\n\n    int port();\n}\n</code></pre> <p>The <code>Server</code> interface is able to map configurations with the name <code>server.host</code> into the <code>Server#host()</code> method and  <code>server.port</code> into <code>Server#port()</code> method. The configuration property name to lookup is built from the prefix, and the  method name with <code>.</code> (dot) as the separator.</p> <p>Warning</p> <p>If a mapping fails to match a configuration property the config system throws a <code>NoSuchElementException</code>, unless  the mapped element is an <code>Optional</code>.</p>"},{"location":"config/mappings/#registration","title":"Registration","text":"<p>Registration of Config Mappings is automatic in CDI aware environments with the <code>@ConfigMapping</code> annotation. </p> <p>In non-CDI environments, the Config Mapping can be registered via <code>SmallRyeConfigBuilder#withMapping</code>. In this case,  the <code>@ConfigMapping</code> is completely optional (but recommendeded to set the prefix).</p> <pre><code>SmallRyeConfig config = new SmallRyeConfigBuilder()\n        .withMapping(Server.class)\n        .build();\n</code></pre>"},{"location":"config/mappings/#retrieval","title":"Retrieval","text":"<p>A config mapping interface can be injected into any CDI aware bean:</p> <pre><code>@ApplicationScoped\nclass BusinessBean {\n    @Inject\n    Server server;\n\n    public void businessMethod() {\n        String host = server.host();\n    }\n}\n</code></pre> <p>In non-CDI environments, use the API <code>io.smallrye.config.SmallRyeConfig#getConfigMapping</code> to retrieve the config  mapping instance:</p> <pre><code>SmallRyeConfig config = ConfigProvider.getConfig().unwrap(SmallRyeConfig.class);\nServer server = config.getConfigMapping(Server.class);\n</code></pre> <p>Info</p> <p>Config Mapping instances are cached. They are populated when the <code>SmallRyeConfig</code> instance is initialized and  their values are not updated on <code>ConfigSource</code> changes. </p> <p>For a Config Mapping to be valid, it needs to match every configuration property name contained in the <code>Config</code> under  the specified prefix set in <code>@ConfigMapping</code>. This prevents unknown configuration properties in the <code>Config</code>. This  behaviour can be disabled with the configuration <code>smallrye.config.mapping.validate-unknown=false</code>, or by ignoring  specified paths with <code>io.smallrye.config.SmallRyeConfigBuilder.withMappingIgnore</code>. </p>"},{"location":"config/mappings/#defaults","title":"Defaults","text":"<p>The <code>io.smallrye.config.WithDefault</code> annotation allows to set a default property value into a mapping (and prevent errors if the configuration value is not available in any <code>ConfigSource</code>).</p> <pre><code>public interface Defaults {\n    @WithDefault(\"foo\")\n    String foo();\n\n    @WithDefault(\"bar\")\n    String bar();\n}\n</code></pre> <p>No configuration properties are required. The <code>Defaults#foo()</code> will return the value <code>foo</code> and <code>Defaults#bar()</code> will return the value <code>bar</code>.</p>"},{"location":"config/mappings/#nested-groups","title":"Nested Groups","text":"<p>A nested mapping provides a way to map sub-groups of configuration properties.</p> <ul> <li>A nested type contributes with its name (converted to its kebab-case format)</li> <li>The configuration path is built by taking the root object type prefix (or namespace), the nested type name and the  member name of the nested type</li> </ul> <pre><code>@ConfigMapping(prefix = \"server\")\npublic interface Server {\n    String host();\n\n    int port();\n\n    Log log();\n\n    interface Log {\n        boolean enabled();\n\n        String suffix();\n\n        boolean rotate();\n    }\n}\n</code></pre> <pre><code>server.host=localhost\nserver.port=8080\nserver.log.enabled=true\nserver.log.suffix=.log\nserver.log.rotate=false\n</code></pre> <p>The method name of a mapping group acts as a sub-prefix in the property name. In this case the matching property to <code>Server.Log#enabled</code> is <code>server.log.enabled</code>.</p>"},{"location":"config/mappings/#hierarchy","title":"Hierarchy","text":"<p>A config mapping can extend another mapping and inherit all its super members:</p> <pre><code>public interface Parent {\n    String name();\n}\n\n@ConfigMapping(prefix = \"child\")\npublic interface Child extends Parent {\n\n}\n</code></pre> <p>And override members:</p> <pre><code>public interface Parent {\n    String name();\n}\n\n@ConfigMapping(prefix = \"child\")\npublic interface Child extends Parent {\n    @WithName(\"child-name\")\n    String name();\n}\n</code></pre>"},{"location":"config/mappings/#overriding-property-names","title":"Overriding property names","text":""},{"location":"config/mappings/#withname","title":"<code>@WithName</code>","text":"<p>If a method name and a property name do not match, the <code>io.smallrye.config.WithName</code> annotation can  override the method name mapping and use the name supplied in the annotation.</p> <pre><code>@ConfigMapping(prefix = \"server\")\ninterface Server {\n    @WithName(\"name\")\n    String host();\n\n    int port();\n}\n</code></pre> <pre><code>server.name=localhost\nserver.port=8080\n</code></pre>"},{"location":"config/mappings/#withparentname","title":"<code>@WithParentName</code>","text":"<p>The <code>io.smallrye.config.WithParentName</code> annotation allows configurations mappings to inherit its parent container name,  simplifying the configuration property name required to match the mapping.</p> <pre><code>@ConfigMapping(prefix = \"server\")\ninterface Server {\n    @WithParentName\n    ServerHostAndPort hostAndPort();\n\n    @WithParentName\n    ServerInfo info();\n}\n\ninterface ServerHostAndPort {\n    String host();\n\n    int port();\n}\n\ninterface ServerInfo {\n    String name();\n}\n</code></pre> <pre><code>server.host=localhost\nserver.port=8080\nserver.name=konoha\n</code></pre> <p>Without the <code>@WithParentName</code> the method <code>ServerInfo#name</code> maps the configuration property <code>server.info.name</code>. With <code>@WithParentName</code>, the <code>Server#info</code> mapping will inherit the parent name from <code>Server</code> and <code>ServerInfo#name</code> maps to  the property <code>server.name</code> instead.</p>"},{"location":"config/mappings/#namingstrategy","title":"NamingStrategy","text":"<p>Method names in camelCase map to kebab-case configuration property names by default.</p> <pre><code>@ConfigMapping(prefix = \"server\")\ninterface Server {\n    String theHost();\n\n    int thePort();\n}\n</code></pre> <pre><code>server.the-host=localhost\nserver.the-port=8080\n</code></pre> <p>The mapping strategy can be adjusted by setting <code>namingStrategy</code> value in the <code>@ConfigMapping</code> annotation.</p> <pre><code>@ConfigMapping(prefix = \"server\", namingStrategy = ConfigMapping.NamingStrategy.VERBATIM)\npublic interface ServerVerbatimNamingStrategy {\n    String theHost();\n\n    int thePort();\n}\n</code></pre> <pre><code>server.theHost=localhost\nserver.thePort=8080\n</code></pre> <p>The <code>@ConfigMapping</code> annotation support the following naming stategies:</p> <ul> <li>KEBAB_CASE - The method name is derived by replacing case changes with a dash to map the configuration property.</li> <li>VERBATIM - The method name is used as is to map the configuration property.</li> <li>SNAKE_CASE - The method name is derived by replacing case changes with an underscore to map the configuration property.</li> </ul>"},{"location":"config/mappings/#conversion","title":"Conversion","text":"<p>A config mapping interface support automatic conversions of all types available for conversion in <code>Config</code>.</p> <pre><code>@ConfigMapping\npublic interface SomeTypes {\n    @WithName(\"int\")\n    int intPrimitive();\n\n    @WithName(\"int\")\n    Integer intWrapper();\n\n    @WithName(\"long\")\n    long longPrimitive();\n\n    @WithName(\"long\")\n    Long longWrapper();\n\n    @WithName(\"float\")\n    float floatPrimitive();\n\n    @WithName(\"float\")\n    Float floatWrapper();\n\n    @WithName(\"double\")\n    double doublePrimitive();\n\n    @WithName(\"double\")\n    Double doubleWrapper();\n\n    @WithName(\"char\")\n    char charPrimitive();\n\n    @WithName(\"char\")\n    Character charWrapper();\n\n    @WithName(\"boolean\")\n    boolean booleanPrimitive();\n\n    @WithName(\"boolean\")\n    Boolean booleanWrapper();\n}\n</code></pre> <pre><code>int=9\nlong=9999999999\nfloat=99.9\ndouble=99.99\nchar=c\nboolean=true\n</code></pre> <p>This is also valid for <code>Optional</code> and friends.</p> <pre><code>@ConfigMapping\npublic interface Optionals {\n    Optional&lt;Server&gt; server();\n\n    Optional&lt;String&gt; optional();\n\n    @WithName(\"optional.int\")\n    OptionalInt optionalInt();\n\n    interface Server {\n        String host();\n\n        int port();\n    }\n}\n</code></pre> <p>In this case, the mapping won\u2019t fail if the configuraton properties values are missing.</p>"},{"location":"config/mappings/#withconverter","title":"<code>@WithConverter</code>","text":"<p>The <code>io.smallrye.config.WithConverter</code> annotation provides a way to set a specific <code>Converter</code> in a mapping.</p> <pre><code>@ConfigMapping\npublic interface Converters {\n    @WithConverter(FooBarConverter.class)\n    String foo();\n}\n\npublic static class FooBarConverter implements Converter&lt;String&gt; {\n    @Override\n    public String convert(final String value) {\n        return \"bar\";\n    }\n}\n</code></pre> <pre><code>foo=foo\n</code></pre> <p>A call to <code>Converters.foo()</code> results in the value <code>bar</code>.</p>"},{"location":"config/mappings/#collections","title":"Collections","text":"<p>A config mapping is also able to map the collections types <code>List</code> and <code>Set</code>.</p> <ul> <li>A member with a <code>Collection</code> type requires the configuration name to be in its indexed format</li> <li>Each configuration name, plus its index maps the configuration value to the corresponding <code>Collection</code> element in the  object type</li> <li>The index must be part of the configuration path, by appending the index between square brackets to the<code>Collection</code>  member</li> <li>The index specified in the configuration name is used to order the element in the <code>Collection</code></li> <li>Missing elements or gaps are removed</li> </ul> <pre><code>@ConfigMapping(prefix = \"server\")\npublic interface ServerCollections {\n    Set&lt;Environment&gt; environments();\n\n    interface Environment {\n        String name();\n\n        List&lt;App&gt; apps();\n\n        interface App {\n            String name();\n\n            List&lt;String&gt; services();\n\n            Optional&lt;List&lt;String&gt;&gt; databases();\n        }\n    }\n}\n</code></pre> <pre><code>server.environments[0].name=dev\nserver.environments[0].apps[0].name=rest\nserver.environments[0].apps[0].services=bookstore,registration\nserver.environments[0].apps[0].databases=pg,h2\nserver.environments[0].apps[1].name=batch\nserver.environments[0].apps[1].services=stock,warehouse\n</code></pre> <p>The <code>List</code> and <code>Set</code> mappings can use Indexed Properties to map configuration values in  mapping groups.</p> <p>Info</p> <p>A <code>List</code> mapping is backed by an <code>ArrayList</code>, and a <code>Set</code> mapping is backed by a <code>HashSet</code>.</p>"},{"location":"config/mappings/#maps","title":"Maps","text":"<p>A config mapping is also able to map a <code>Map</code>.</p> <ul> <li>A member with a <code>Map</code> type requires an additional configuration name added to the configuration path of the <code>Map</code> member to act as a map key</li> <li>The additional configuration name maps a Map entry with the configuration name as the <code>Map</code> entry key and  the configuration value as the Map entry value</li> </ul> <pre><code>@ConfigMapping(prefix = \"server\")\npublic interface Server {\n    String host();\n\n    int port();\n\n    Map&lt;String, String&gt; form();\n\n    Map&lt;String, List&lt;Alias&gt;&gt; aliases();\n\n    interface Alias {\n        String name();\n    }\n}\n</code></pre> <pre><code>server.host=localhost\nserver.port=8080\nserver.form.index=index.html\nserver.form.login.page=login.html\nserver.form.error.page=error.html\nserver.aliases.localhost[0].name=prod\nserver.aliases.localhost[1].name=127.0.0.1\nserver.aliases.\\\"io.smallrye\\\"[0].name=smallrye\n</code></pre> <p>The configuration property name needs to specify an additional segment to act as the map key. The <code>server.form</code> matches  the <code>Server#form</code> <code>Map</code> and the segments <code>index</code>, <code>login.page</code> and <code>error.page</code> represent the <code>Map</code>  keys.</p> <p>Info</p> <p>A <code>Map</code> mapping is backed by an <code>HashMap</code>.</p> <p>When populating a <code>Map</code>, <code>SmallRyeConfig</code> requires the configuration names listed in  <code>SmallRyeConfig#getPropertyNames</code> to find the <code>Map</code> keys. If a <code>ConfigSource</code> does not support  <code>getPropertyNames</code> (empty), the names must be provided by another <code>ConfigSource</code> that can do so. After retrieving the  map keys, <code>SmallRyeConfig</code> performs the lookup of the values with the regular <code>ConfigSource</code> ordinal ordering. Even if  a <code>ConfigSource</code> does not provide <code>getPropertyNames</code> it can provide the value by having the name listed in another  capable <code>ConfigSource</code>.</p> <p>For collection types, the key requires the indexed format. The configuration name <code>server.aliases.localhost[0].name</code>  maps to the <code>Map&lt;String, List&lt;Alias&gt;&gt; aliases()</code> member, where <code>localhost</code> is the <code>Map</code> key, <code>[0]</code> is the index of the  <code>List&lt;Alias&gt;</code> collection where the <code>Alias</code> element will be stored, containing the name <code>prod</code>.</p> <p>Info</p> <p>They <code>Map</code> key part in the configuration property name may require quotes to delimit the key.</p>"},{"location":"config/mappings/#withunnamedkey","title":"<code>@WithUnnamedKey</code>","text":"<p>The <code>io.smallrye.config.WithUnnamedKey</code> annotation allows to omit a single map key in the configuration path:</p> <pre><code>@ConfigMapping(prefix = \"server\")\npublic interface Server {\n    @WithUnnamedKey(\"localhost\")\n    Map&lt;String, Alias&gt; aliases();\n\n    interface Alias {\n        String name();\n    }\n}\n</code></pre> <pre><code>server.aliases.name=localhost\nserver.aliases.prod.name=prod\n</code></pre> <p>The <code>sever.aliases.name</code> is an unnamed <code>Map</code> property, because it does not contain the <code>Map</code> key to populate the <code>Map</code>  entry. Due to <code>@WithUnnamedKey(\"localhost\")</code> the <code>Map</code> key is not required in the configuration path. The key used to  look up the Map entry is given by <code>io.smallrye.config.WithUnnamedKey#value</code>:</p> <pre><code>Server server = config.getConfigMapping(Server.class);\nMap&lt;String, Alias&gt; localhost = server.aliases.get(\"localhost\");\n</code></pre> <p>Warning</p> <p>If the unnamed key (in this case <code>localhost</code>) is explicitly set in a property name, the mapping will throw an error.</p>"},{"location":"config/mappings/#withkeys","title":"<code>@WithKeys</code>","text":"<p>The <code>io.smallrye.config.WithKeys</code> annotation allows to define which <code>Map</code> keys must be loaded by  the configuration: </p> <pre><code>@ConfigMapping(prefix = \"server\")\npublic interface Server {\n    @WithKeys(KeysProvider.class)\n    Map&lt;String, Alias&gt; aliases();\n\n    interface Alias {\n        String name();\n    }\n\n    class KeysProvider implements Supplier&lt;Iterable&lt;String&gt;&gt; {\n        @Override\n        public Iterable&lt;String&gt; get() {\n            return List.of(\"dev\", \"test\", \"prod\");\n        }\n    }\n}\n</code></pre> <p>In this case, <code>SmallRyeConfig</code> will look for the map keys <code>dev</code>, <code>test</code> and <code>prod</code> instead of discovering the keys  with <code>SmallRyeConfig#getPropertyNames</code>:</p> <pre><code>servers.alias.dev.name=dev\nservers.alias.test.name=test\nservers.alias.prod.name=prod\n</code></pre> <p>The provided list will effectively substitute the lookup in <code>SmallRyeConfig#getPropertyNames</code>, thus enabling a <code>ConfigSource</code> that does not list its properties, to contribute configuration to the <code>Map</code>.  Each key must exist in  the final configuration (relative to the <code>Map</code> path segment), or the mapping will fail with a  <code>ConfigValidationException</code>.</p>"},{"location":"config/mappings/#withdefaults","title":"<code>@WithDefaults</code>","text":"<p>The <code>io.smallrye.config.WithDefaults</code> is a marker annotation to use only in a <code>Map</code> to return the default value for the value element on any key lookup:</p> <pre><code>@ConfigMapping(prefix = \"server\")\npublic interface Server {\n    @WithDefaults\n    Map&lt;String, Alias&gt; aliases();\n\n    interface Alias {\n        @WithDefault(\"localhost\")\n        String name();\n    }\n}\n</code></pre> <pre><code>server.aliases.prod.name=prod\n</code></pre> <p>A look-up to the <code>aliases</code> <code>Map</code> with the key <code>localhost</code>, <code>any</code> or any other key, returns a <code>Alias</code> instance, where <code>Alias.name</code> is <code>localhost</code>, which is the default value. A look-up to <code>prod</code> returns a <code>Alias</code> instance, where <code>Alias.name</code> is <code>prod</code> because the property is defined in the configuration as <code>server.aliases.prod.name=prod</code>.</p> <p>The <code>Map</code> can only iterate and size the defined keys. In this case, the <code>aliases</code> <code>Map</code> only iterates the <code>prod</code> key, and the size is <code>1</code>.</p> <pre><code>Server server = config.getConfigMapping(Server.class);\nMap&lt;String, Alias&gt; localhost = server.aliases.get(\"localhost\");\nMap&lt;String, Alias&gt; any = server.aliases.get(\"any\");\nMap&lt;String, Alias&gt; any = server.aliases.get(\"prod\");\n</code></pre>"},{"location":"config/mappings/#optionals","title":"Optionals","text":"<ul> <li>A mapping can wrap any complex type with an <code>Optional</code></li> <li><code>Optional</code> mappings do not require the configuration path and value to be present</li> </ul>"},{"location":"config/mappings/#tostring-equals-hashcode","title":"toString, equals, hashcode","text":"<p>If the config mapping contains a <code>toString</code> method declaration, the config mapping instance will include a proper implementation of the <code>toString</code> method. The <code>equals</code> and <code>hashcode</code> methods are included automatically.</p> <p>Caution</p> <p>Do not include a <code>toString</code> declaration in a config mapping with sensitive information.</p>"},{"location":"config/mappings/#validation","title":"Validation","text":"<p>A config mapping may combine annotations from Bean Validation to validate configuration  properties values.</p> <pre><code>@ConfigMapping(prefix = \"server\")\ninterface Server {\n    @Size(min = 2, max = 20)\n    String host();\n\n    @Max(10000)\n    int port();\n}\n</code></pre> <p>The application startup fails with a <code>io.smallrye.config.ConfigValidationException</code> if the configuration properties  values do not follow the contraints defined in <code>Server</code>. </p> <p>Info</p> <p>For validation to work, the <code>smallrye-config-validator</code> dependency is required in the classpath.</p>"},{"location":"config/profiles/","title":"Profiles","text":"<p>Applications often require different configurations depending on the target environment. For example, the local  development environment may be different from the production environment. Profiles allow for multiple configurations  in the same file or separate files and select between them via a profile name.</p>"},{"location":"config/profiles/#profile-aware-properties","title":"Profile aware properties","text":"<p>To be able to set properties with the same name, each property needs to be prefixed with a percentage sign <code>%</code> followed  by the profile name and a dot <code>.</code> in the syntax <code>%{profile-name}.config.name</code>:</p> META-INF/microprofile-config.properties<pre><code>http.port=8080\n%dev.http.port=8181\n</code></pre> <p>To activate the profile <code>dev</code>, the configuration <code>smallrye.config.profile=dev</code> has to be set into any valid  <code>ConfigSource</code>.</p> <p>Any lookup to the <code>http.port</code> property name will first search by the active profile name <code>%dev.http.port</code> and then  fallback to <code>http.port</code> if no value is present. In this case a lookup to the property <code>http.port</code> with the <code>dev</code> profile  active, yields the value <code>8181</code>.</p> <p>Attention</p> <p>The profile must be set in one of the primary sources (system properties, environment variables,  <code>application.properties</code>, or any other source that does not require configuration) to determine the proper  configuration.</p>"},{"location":"config/profiles/#profile-aware-files","title":"Profile aware files","text":"<p>Properties for a specific profile may reside in a <code>microprofile-config-{profile}.properties</code> named file. The previous  example can be expressed as:</p> META-INF/microprofile-config.properties<pre><code>http.port=8080\n</code></pre> META-INF/microprofile-config-dev.properties<pre><code>http.port=8181\n</code></pre> <p>In this style, the property names in the profile aware file do not need to be prefixed with the profile name.</p> <p>Note</p> <p>Properties in the profile aware file have priority over profile aware properties defined in the main file.</p> <p>Attention</p> <p>Do not use Profile aware files to set <code>smallrye.config.profile</code>. This will not work because the  the profile is required in advance to load the profile aware files.</p>"},{"location":"config/profiles/#priority","title":"Priority","text":"<p>Profile lookups are only valid if the <code>ConfigSource</code> has a higher ordinal than a lookup to the regular configuration  name. Consider:</p> main.properties<pre><code>config_ordinal=1000\nhttp.port=8080\n</code></pre> profile.properties<pre><code>config_ordinal=100\n%dev.http.port=8181\n</code></pre> <p>Even with the profile <code>dev</code> active, the lookup value for <code>my.prop</code> is <code>1234</code>. This prevents lower ordinal sources to  set a profile property value that cannot be overridden unless the profile property is also overridden.</p>"},{"location":"config/profiles/#multiple-profiles","title":"Multiple Profiles","text":"<p>Multiple Profiles may be active at the same time. The configuration <code>smallrye.config.profile</code> accepts a comma-separated  list of profile names: <code>smallrye.config.profile=common,dev</code>. Both <code>common</code> and <code>dev</code> are separate profiles.</p> <p>When multiple profiles are active, the rules for profile configuration are the same. If two profiles define the same  configuration, then the last listed profile has priority. Consider:</p> <pre><code>smallrye.config.profile=common,dev\n\nmy.prop=1234\n%common.my.prop=1234\n%dev.my.prop=5678\n\n%common.commom.prop=common\n%dev.dev.prop=dev\n%test.test.prop=test\n</code></pre> <p>Then</p> <ul> <li><code>common.prop</code> value is <code>common</code></li> <li><code>dev.prop</code> value is <code>dev</code></li> <li><code>my.prop</code> value is <code>5678</code></li> <li><code>test.prop</code> does not have a value</li> </ul> <p>It is also possible to define multiple profile properties, with a comma-separated list of profile names:</p> <pre><code>%prod,dev.my.prop=1234\n</code></pre> <p>The property name <code>common.prop</code> is active in both <code>dev</code> and <code>prod</code> profile. If the same property name exists in  multiple profile properties then, the property name with the most specific profile wins:</p> <pre><code>smallrye.config.profile=dev\n\n%prod,dev.my.prop=1234\n\n%dev.my.prop=5678\n</code></pre> <p>Then <code>my.prop</code> value is <code>5678</code>.</p>"},{"location":"config/profiles/#parent-profile","title":"Parent Profile","text":"<p>A Parent Profile adds multiple levels of hierarchy to the current profile. The configuration  <code>smallrye.config.profile.parent</code> also acccepts a comma-separated list of profile names.</p> <p>When the Parent Profile is active, if a property cannot be found in the current active Profile, the config lookup  fallbacks to the Parent Profile. Consider:</p> <pre><code>smallrye.config.profile=dev\nsmallrye.config.profile.parent=common\n\nmy.prop=1234\n%common.my.prop=0\n%dev.my.prop=5678\n\n%common.commom.prop=common\n%dev.dev.prop=dev\n%test.test.prop=test\n</code></pre> <p>Then</p> <ul> <li><code>common.prop</code> value is <code>common</code></li> <li><code>dev.prop</code> value is <code>dev</code></li> <li><code>my.prop</code> value is <code>0</code></li> <li><code>test.prop</code> does not have a value</li> </ul> <p>Attention</p> <p>Do not use Profile aware files to set smallrye.config.profile.parent`. This will not work because the  the profile is required in advance to load the profile aware files.</p>"},{"location":"config/profiles/#multi-level-hierarchy","title":"Multi-level Hierarchy","text":"<p>The Parent Profile also supports multiple levels of hierarchies:</p> <pre><code>smallrye.config.profile=child\n%child.smallrye.config.profile.parent=parent\n%parent.smallrye.config.profile.parent=grandparent\n%grandparent.smallrye.config.profile.parent=greatgrandparent\n%greatgrandparent.smallrye.config.profile.parent=end\n</code></pre> <p>Will load the following profiles in order: <code>child</code>, <code>parent</code>, <code>grandparent</code>, <code>greatgrandparent</code>, <code>end</code> </p>"},{"location":"config/secret-keys/","title":"Secret Keys","text":""},{"location":"config/secret-keys/#secret-keys-expressions","title":"Secret Keys Expressions","text":"<p>In SmallRye Config, a secret configuration may be expressed as <code>${handler::value}</code>, where the <code>handler</code> is the name of  a <code>io.smallrye.config.SecretKeysHandler</code> to decode or decrypt the <code>value</code> separated by a double colon <code>::</code>.</p> <p>It is possible to create a custom <code>SecretKeysHandler</code> and provide different ways to decode or decrypt configuration  values. </p> <p>A custom <code>SecretKeysHandler</code> requires an implementation of <code>io.smallrye.config.SecretKeysHandler</code> or  <code>io.smallrye.config.SecretKeysHandlerFactory</code>. Each implementation requires registration via the <code>ServiceLoader</code>  mechanism, either in <code>META-INF/services/io.smallrye.config.SecretKeysHandler</code> or <code>META-INF/services/io.smallrye.config.SecretKeysHandlerFactory</code> files.</p> <p>Danger</p> <p>It is not possible to mix Secret Keys Expressions with Property Expressions.</p>"},{"location":"config/secret-keys/#crypto","title":"Crypto","text":"<p>The <code>smallrye-config-crypto</code> artifact contains a few out-of-the-box <code>SecretKeysHandler</code>s ready for use. It requires  the following dependency:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.config&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-config-crypto&lt;/artifactId&gt;\n    &lt;version&gt;3.13.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"config/secret-keys/#aesgcmnopadding-aes-gcm-nopadding","title":"AES/GCM/NoPadding <code>${aes-gcm-nopadding::...}</code>","text":"<ul> <li>The encoding length is 128.</li> <li>The secret and the encryption key (without padding) must be base 64 encoded.</li> </ul> <p>Example</p> application.properties<pre><code>smallrye.config.secret-handler.aes-gcm-nopadding.encryption-key=DDne5obnfH1RSeTg71xSZg\n\nmy.secret=${aes-gcm-nopadding::DLTb_9zxThxeT5iAQqswEl5Dn1ju4FdM9hIyVip35t5V}\n</code></pre> <p>The <code>${aes-gcm-nopadding::...}</code> <code>SecretKeyHandler</code> requires  <code>smallrye.config.secret-handler.aes-gcm-nopadding.encryption-key</code> configuration to state the encryption key to be  used by the <code>aes-gcm-nopaddin</code> handler.</p> <p>A lookup to <code>my.secret</code> will use the <code>SecretKeysHandler</code> name <code>aes-gcm-nopadding</code> to decode the value  <code>DJNrZ6LfpupFv6QbXyXhvzD8eVDnDa_kTliQBpuzTobDZxlg</code>.</p> <p>Info</p> <p>It is possible to generate the encrypted secret with the following JBang script:</p> <pre><code>jbang https://raw.githubusercontent.com/smallrye/smallrye-config/main/documentation/src/main/docs/config/secret-handlers/encryptor.java -s=&lt;secret&gt; -k=&lt;encryptionKey&gt;`\n</code></pre>"},{"location":"config/secret-keys/#configuration","title":"Configuration","text":"Configuration Property Type Default <code>smallrye.config.secret-handler.aes-gcm-nopadding.encryption-key</code>The encryption key to use to decode secrets encoded by the <code>AES/GCM/NoPadding</code> algorithm. String <code>\"smallrye.config.secret-handler.aes-gcm-nopadding.encryption-key-decode\"</code>Decode the encryption key in Base64, if the plain text key was used to encrypt the secret. boolean false"},{"location":"config/secret-keys/#jasypt","title":"Jasypt","text":"<p>Jasypt is a java library which allows the developer to add basic encryption capabilities. Add  the following dependency in your project to use it:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.config&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-config-jasypt&lt;/artifactId&gt;\n    &lt;version&gt;3.13.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"config/secret-keys/#jasypt-jasypt","title":"Jasypt <code>${jasypt::...}</code>","text":"<p>Example</p> <p>application.properties<pre><code>smallrye.config.secret-handler.jasypt.password=jasypt\nsmallrye.config.secret-handler.jasypt.algorithm=PBEWithHMACSHA512AndAES_256\n\nmy.secret=${jasypt::ENC(wqp8zDeiCQ5JaFvwDtoAcr2WMLdlD0rjwvo8Rh0thG5qyTQVGxwJjBIiW26y0dtU)}\n</code></pre> The <code>${jasypt::...}</code> <code>SecretKeyHandler</code> requires both <code>smallrye.config.secret-handler.jasypt.password</code> and  <code>smallrye.config.secret-handler.jasypt.algorithm</code> configurations to state the password and the algorithm to be used by the Jasypt encryptor.</p> <p>Jasypt encrypted values must be set with the handler expression as <code>${jasypt::ENC(value)}</code>. Note that the  encrypted value must be generated using the proper Jasypt encryptor with the same password and algorithm set in  the confguration.</p> <p>A possible encrypted value for <code>12345678</code> is <code>ENC(wqp8zDeiCQ5JaFvwDtoAcr2WMLdlD0rjwvo8Rh0thG5qyTQVGxwJjBIiW26y0dtU)</code></p> <p>Lookups to the configuration <code>my.secret</code> will automatically decrypt the value with Jasypt and provide the original <code>12345678</code> string.</p> <p>Info</p> <p>It is possible to generate the encrypted secret with the following JBang script:</p> <pre><code>jbang https://raw.githubusercontent.com/smallrye/smallrye-config/main/documentation/src/main/docs/config/secret-handlers/jasypt.java -s=&lt;secret&gt; -p=&lt;password&gt;\n</code></pre>"},{"location":"config/secret-keys/#configuration_1","title":"Configuration","text":"Configuration Property Type Default <code>smallrye.config.secret-handler.jasypt.password</code>The Jasypt password to use String <code>smallrye.config.secret-handler.jasypt.algorithm</code>The Jasypt algorithm to use String"},{"location":"config/secret-keys/#secret-keys-names","title":"Secret Keys Names","text":"<p>When configuration properties contain passwords or other kinds of secrets, Smallrye Config can hide them to prevent  accidental exposure of such values.</p> <p>This is no way a replacement for securing secrets. Proper security mechanisms must still be used to secure  secrets. However, there is still the fundamental problem that passwords and secrets are generally encoded simply as  strings. Secret Keys provides a way to \u201clock\u201d the configuration so that secrets do not appear unless explicitly enabled.</p> <p>To mark specific keys as secrets, register an instance of <code>io.smallrye.config.SecretKeysConfigSourceInterceptor</code> by  using the interceptor factory as follows:</p> <pre><code>public class SecretKeysConfigInterceptorFactory implements ConfigSourceInterceptorFactory {\n    @Override\n    public ConfigSourceInterceptor getInterceptor(ConfigSourceInterceptorContext context) {\n        return new SecretKeysConfigSourceInterceptor(Set.of(\"secret\"));\n    }\n}\n</code></pre> <p>Register the factory so that it can be found at runtime by creating a  <code>META-INF/services/io.smallrye.config.ConfigSourceInterceptorFactory</code> file that contains the fully qualified name of  this factory class.</p> <p>From this point forward, every lookup to the configuration name <code>secret</code> will throw a <code>SecurityException</code>.</p> <p>Access the Secret Keys using the APIs <code>io.smallrye.config.SecretKeys#doUnlocked(java.lang.Runnable)</code>  and <code>io.smallrye.config.SecretKeys#doUnlocked(java.util.function.Supplier&lt;T&gt;)</code>.</p> <pre><code>String secretValue = SecretKeys.doUnlocked(() -&gt; {\n    config.getValue(\"secret\", String.class);\n});\n</code></pre> <p>Secret Keys are only unlocked in the context of <code>doUnlocked</code>. Once the execution completes, the secrets become locked  again.</p>"},{"location":"config-sources/custom/","title":"Config Sources","text":""},{"location":"config-sources/custom/#custom-configsource","title":"Custom <code>ConfigSource</code>","text":"<p>It\u2019s possible to create a custom ConfigSource as specified in  MicroProfile Config.</p> <p>With a Custom <code>ConfigSource</code> it is possible to read additional configuration values and add them to the <code>Config</code>  instance in a defined ordinal. This allows overriding values from other sources or falling back to other values.</p> <p>A custom <code>ConfigSource</code> requires an implementation of <code>org.eclipse.microprofile.config.spi.ConfigSource</code> or  <code>org.eclipse.microprofile.config.spi.ConfigSourceProvider</code>. Each implementation requires registration via the  <code>ServiceLoader</code> mechanism, either in <code>META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource</code> or  <code>META-INF/services/org.eclipse.microprofile.config.spi.ConfigSourceProvider</code> files.</p> <p>Consider a simple in-memory ConfigSource:</p> <pre><code>package org.acme.config;\n\nimport org.eclipse.microprofile.config.spi.ConfigSource;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class InMemoryConfigSource implements ConfigSource {\n    private static final Map&lt;String, String&gt; configuration = new HashMap&lt;&gt;();\n\n    static {\n        configuration.put(\"my.prop\", \"1234\");\n    }\n\n    @Override\n    public int getOrdinal() {\n        return 350;\n    }\n\n    @Override\n    public Set&lt;String&gt; getPropertyNames() {\n        return configuration.keySet();\n    }\n\n    @Override\n    public String getValue(final String propertyName) {\n        return configuration.get(propertyName);\n    }\n\n    @Override\n    public String getName() {\n        return InMemoryConfigSource.class.getSimpleName();\n    }\n}\n</code></pre> <p>And registration in:</p> META-INF/services/org.eclipse.microprofile.config.spi.ConfigSource<pre><code>org.acme.config.InMemoryConfigSource\n</code></pre> <p>The <code>InMemoryConfigSource</code> will be ordered between the <code>System properties</code> config source, and the  <code>Environment variables</code> config source due to the <code>350</code> ordinal.</p> <p>In this case, <code>my.prop</code> from <code>InMemoryConfigSource</code> will only be used if the <code>Config</code> instance is unable to find a  value in <code>System Properties</code>, ignoring all the other lower ordinal config sources.</p>"},{"location":"config-sources/custom/#configsourcefactory","title":"<code>ConfigSourceFactory</code>","text":"<p>Another way to create a <code>ConfigSource</code> is via the SmallRye Config <code>io.smallrye.config.ConfigSourceFactory</code> API. The  difference between the SmallRye Config factory and the standard way to create a <code>ConfigSource</code> as specified in MicroProfile Config, is the factory ability to provide a context  with access to the current configuration.</p> <p>Each implementation of <code>io.smallrye.config.ConfigSourceFactory</code> requires registration via the <code>ServiceLoader</code> mechanism  in the <code>META-INF/services/io.smallrye.config.ConfigSourceFactory</code> file.</p> <pre><code>package org.acme.config;\n\nimport java.util.Collections;\nimport java.util.OptionalInt;\n\nimport org.eclipse.microprofile.config.spi.ConfigSource;\n\nimport io.smallrye.config.ConfigSourceContext;\nimport io.smallrye.config.ConfigSourceFactory;\nimport io.smallrye.config.ConfigValue;\nimport io.smallrye.config.PropertiesConfigSource;\n\npublic class URLConfigSourceFactory implements ConfigSourceFactory {\n    @Override\n    public Iterable&lt;ConfigSource&gt; getConfigSources(final ConfigSourceContext context) {\n        final ConfigValue value = context.getValue(\"config.url\");\n        if (value == null || value.getValue() == null) {\n            return Collections.emptyList();\n        }\n\n        try {\n            return Collections.singletonList(new PropertiesConfigSource(new URL(value.getValue())));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public OptionalInt getPriority() {\n        return OptionalInt.of(290);\n    }\n}\n</code></pre> <p>And registration in:</p> META-INF/services/io.smallrye.config.ConfigSourceFactory<pre><code>org.acme.config.URLConfigSourceFactory\n</code></pre> <p>By implementing <code>io.smallrye.config.ConfigSourceFactory</code>, a list of <code>ConfigSource</code> may be provided via the  <code>Iterable&lt;ConfigSource&gt; getConfigSources(ConfigSourceContext context)</code> method. The <code>ConfigSourceFactory</code> may also  assign a priority by overriding the method <code>OptionalInt getPriority()</code>. The priority value is used to sort multiple  <code>io.smallrye.config.ConfigSourceFactory</code> (if found). Higher the value, higher the priority.</p> <p>Warning</p> <p>The <code>io.smallrye.config.ConfigSourceFactory</code> priority does not affect the <code>ConfigSource</code> ordinal. These are sorted  independently.</p> <p>When the Factory is initializing, the provided <code>ConfigSourceContext</code> may call the method  <code>ConfigValue getValue(String name)</code>. This method looks up configuration names in all <code>ConfigSource</code>s that were already  initialized by the <code>Config</code> instance, including sources with lower ordinals than the ones defined in the  <code>ConfigSourceFactory</code>. This means that a <code>Config</code> instance is initialized in two steps: first all <code>ConfigSource</code> and  <code>ConfigSourceProvider</code> and then the <code>ConfigSourceFactory</code>. Only configuation values found in the first step are avaible to the `ConfigSourceFactory. </p> <p>The <code>ConfigSource</code> list provided by a <code>ConfigSourceFactory</code> is not taken into consideration to  configure other sources produced by a lower priority <code>ConfigSourceFactory</code>.</p>"},{"location":"config-sources/custom/#override-configsource-ordinal","title":"Override <code>ConfigSource</code> ordinal","text":"<p>The special configuration property name <code>config_ordinal</code> can be set in any <code>ConfigSource</code> to override its default  ordinal.</p> <p>For instance, setting the system property <code>-Dconfig_ordinal=200</code> will override the ordinal for the <code>System properties</code>  config source and move it to be looked up after the <code>Environment Variables</code> config source.</p>"},{"location":"config-sources/custom/#properties","title":"Properties","text":"<p>The PropertiesConfigSource  creates a <code>ConfigSource</code> from Java <code>Properties</code>, <code>Map&lt;String, String&gt;</code> objects or a <code>.properties</code> file (referenced by its URL).</p>"},{"location":"config-sources/custom/#env","title":"<code>.env</code>","text":"<p>The DotEnvConfigSourceProvider create a <code>ConfigSource</code> from a <code>.env</code> file.</p>"},{"location":"config-sources/factories/","title":"Config Source Factory","text":"<p>Another way to create a <code>ConfigSource</code> is via the <code>ConfigSourceFactory</code>. The difference between the SmallRye Config  Factory and the standard way to make a <code>ConfigSource</code> as specified in MicroProfile Config is the Factory\u2019s ability to  provide a context with access to the available configuration. With the <code>ConfigSourceFactory</code> it is possible to  bootstrap a <code>ConfigSource</code> that configures itself with previously initialized <code>ConfigSource's</code>.</p> <p>By implementing  ConfigSourceFactory,  a list of <code>ConfigSource's</code> may be provided via the <code>Iterable&lt;ConfigSource&gt; getConfigSources(ConfigSourceContext context)</code> method. The <code>ConfigSourceFactory</code> may also  assign a priority by overriding the default method <code>OptionalInt getPriority()</code>. The priority only sorts the factories  during initialization. After initialization, the provided <code>ConfigSources</code> will use their own ordinal and sorted with  all <code>ConfigSources</code> available in the <code>Config</code> instance.</p> <p>When the Factory initializes, the provided <code>ConfigSourceContext</code> may call the method  <code>ConfigValue getValue(String name)</code>. This method looks up configuration names in all <code>ConfigSource's</code> already  initialized by the <code>Config</code> instance, including sources with lower ordinals than the ones defined in the  <code>ConfigSourceFactory</code>. The <code>ConfigSourceFactory</code> does not consider <code>ConfigSources's</code> provided by other  <code>ConfigSourceFactory's</code> (the priority does not matter).</p> <p>Registration of a <code>ConfigSourceFactory</code> is done via the <code>ServiceLoader</code> mechanism by providing the implementation classes in a <code>META-INF/services/io.smallrye.config.ConfigSourceFactory</code> file. Alternatively, factories may be registered via the Programmatic API in <code>SmallRyeConfigBuilder#withSources</code>.</p> <p>A <code>ConfigSourceFactory</code> requires an implementation of <code>io.smallrye.config.ConfigSourceFactory</code>. Each implementation  requires registration via the <code>ServiceLoader</code> mechanism in the  <code>META-INF/services/io.smallrye.config.ConfigSourceFactory</code> file. Alternatively, interceptors may be registered via the  Programmatic API in <code>SmallRyeConfigBuilder#withSources</code>.</p> <pre><code>package org.acme.config\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.eclipse.microprofile.config.spi.ConfigSource;\n\nimport io.smallrye.config._private.ConfigMessages;\nimport io.smallrye.config.PropertiesConfigSource;\nimport io.smallrye.config.ConfigSourceContext;\nimport io.smallrye.config.ConfigSourceFactory;\nimport io.smallrye.config.ConfigValue;\n\npublic class FileSystemConfigSourceFactory implements ConfigSourceFactory {\n    @Override\n    public Iterable&lt;ConfigSource&gt; getConfigSources(final ConfigSourceContext context) {\n        final ConfigValue value = context.getValue(\"org.acme.config.file.locations\");\n        if (value == null || value.getValue() == null) {\n            return Collections.emptyList();\n        }\n\n        try {\n            return List.of(new PropertiesConfigSource(toURL(value.getValue()), 250));\n        } catch (IOException e) {\n            return Collections.emptyList();\n        }\n    }\n\n    private URL toURL(final String value) {\n        try {\n            return new URI(value).toURL();\n        } catch (URISyntaxException | MalformedURLException e) {\n            throw ConfigMessages.msg.uriSyntaxInvalid(e, value);\n        }\n    }\n}\n</code></pre> <p>And registration in:</p> META-INF/services/io.smallrye.config.ConfigSourceFactory<pre><code>org.acme.config.FileSystemConfigSourceFactory\n</code></pre> <p>The <code>FileSystemConfigSourceFactory</code> look ups the configuration value for <code>org.acme.config.file.locations</code>, and uses it  to set up an additional <code>ConfigSource</code>.</p> <p>Alternatively, a <code>ConfigurableConfigSourceFactory</code> accepts a <code>ConfigMapping</code> interface to configure the <code>ConfigSource</code>:</p> <pre><code>@ConfigMapping(prefix = \"org.acme.config.file\")\ninterface FileSystemConfig {\n    List&lt;URL&gt; locations();   \n}\n</code></pre> <pre><code>public class FileSystemConfigurableConfigSourceFactory implements ConfigurableConfigSourceFactory&lt;FileSystemConfig&gt; {\n    @Override\n    public Iterable&lt;ConfigSource&gt; getConfigSources(ConfigSourceContext context, FileSystemConfig config) {\n\n    }\n}\n</code></pre> <p>With a <code>ConfigurableConfigSourceFactory</code> it is not required to look up the configuration values with  <code>ConfigSourceContext</code>. The values are automatically mapped with the defined <code>@ConfigMapping</code>.</p>"},{"location":"config-sources/filesystem/","title":"FileSystem Config Source","text":"<p>This Config Source loads configuration values for each file found in a directory. Each file corresponds to a single  property, where the file name is the configuration property name and the file content the configuration value.</p> <p>For instance, if a directory structure looks like:</p> <pre><code>foo/\n|__num.max\n|__num.size\n</code></pre> <p>The <code>FileSystem</code> Config Source will provide 2 properties:</p> <ul> <li>num.max</li> <li>num.size</li> </ul> <p>Warning</p> <p>Nested directories are not supported.</p> <p>This Config Source can be used to read configuration from Kubernetes ConfigMap. Check the  Kubernetes ConfigMap ConfigSource Example.</p> <p>The same mapping rules as defined for environment variables are applied, so the <code>FileSystem</code> Config Source will search  for a given property name <code>num.max</code>:</p> <ul> <li>Exact match (<code>num.max</code>)</li> <li>Replace each character that is neither alphanumeric nor _ with _ (<code>num_max</code>)</li> <li>Replace each character that is neither alphanumeric nor _ with _; then convert the name to upper case (<code>NUM_MAX</code>)</li> </ul> <p>The following dependency is required in the classpath to use the <code>FileSystem</code> Config Source:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.config&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-config-source-file-system&lt;/artifactId&gt;\n    &lt;version&gt;3.13.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>The configuration property <code>smallrye.config.source.file.locations</code> sets the directory paths to look up the files. It  accepts multiple locations separated by a comma and each must represent a valid URI to a directory.</p>"},{"location":"config-sources/hocon/","title":"HOCON Config Source","text":"<p>This Config Source allows to use the HOCON file format to  load configuration values. The HOCON Config Source loads the configuration from the file <code>META-INF/microprofile-config.conf</code>. It has a lower ordinal (<code>50</code>) than the <code>microprofile-config.properties</code>.</p> <p>The following dependency is required in the classpath to use the HOCON Config Source:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.config&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-config-source-hocon&lt;/artifactId&gt;\n    &lt;version&gt;3.13.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Expressions defined as <code>${value}</code> (unquoted) are resolved internally by the HOCON Config Source as described in the HOCON Substitutions documentation. Quoted  Expressions defined as <code>\"${value}\"</code> are resolved by SmallRye Config Property Expressions.</p> <p>Consider:</p> <p>hocon.conf <pre><code>{\n   foo: \"bar\",\n   hocon: ${foo},\n   config: \"${foo}\" \n}\n</code></pre></p> <p>application.properties <pre><code>config_ordinal=1000\nfoo=baz\n</code></pre></p> <p>The value of <code>hocon</code> is <code>bar</code> and the value of <code>config</code> is <code>baz</code> (if the properties source has a higher ordinal).</p>"},{"location":"config-sources/json/","title":"JSON Config Source","text":"<p>The YAML Config Source also accepts the JSON format as its contents. The configuration file  <code>META-INF/microprofile-config.yaml</code>, still requires to use the <code>yaml</code> extension.</p>"},{"location":"config-sources/keystore/","title":"KeyStore Config Source","text":"<p>This Config Source allows to use a Java <code>KeyStore</code> to load configuration values. It uses an ordinal of <code>100</code>.</p> <p>The following dependency is required in the classpath to use the KeyStore Config Source:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.config&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-config-source-keystore&lt;/artifactId&gt;\n    &lt;version&gt;3.13.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"config-sources/keystore/#create-a-keystore","title":"Create a KeyStore","text":"<p>The following command creates a simple KeyStore</p> <pre><code>keytool -importpass -alias my.secret -keystore keystore -storepass secret -storetype PKCS12 -v\n</code></pre> <p>The <code>-alias my.secret</code> stores the configuration property name <code>my.secret</code> in the KeyStore. The command will  interactively ask for the value to be stored in the KeyStore.</p>"},{"location":"config-sources/keystore/#read-the-keystore","title":"Read the KeyStore","text":"<p>The KeyStore Config Source supports reading multiple keystore files:</p> <pre><code>smallrye.config.source.keystore.one.path=keystore-one\nsmallrye.config.source.keystore.one.password=password\n\nsmallrye.config.source.keystore.two.path=keystore-two\nsmallrye.config.source.keystore.two.password=password\n</code></pre> <p>The names are arbitrary and can be any name. The name <code>one</code> and <code>two</code> are used to distinguish both KeyStores.  </p> <p>If a stored configuration property requires a Secret Handler to decode a value, set  the handler name with <code>smallrye.config.source.keystore.\"name\".handler</code>.</p>"},{"location":"config-sources/keystore/#configuration","title":"Configuration","text":"Configuration Property Type Default <code>smallrye.config.source.keystore.\"name\".path</code>The KeyStore path. String <code>smallrye.config.source.keystore.\"name\".password</code>The KeyStore password. String <code>smallrye.config.source.keystore.\"name\".type</code>The KeyStore type. String <code>PKCS12</code> <code>smallrye.config.source.keystore.\"name\".handler</code>An Optional secret keys handler. String <code>smallrye.config.source.keystore.\"name\".aliases.\"key\".name</code>An Optional aliases key name. String <code>smallrye.config.source.keystore.\"name\".aliases.\"key\".password</code>An Optional aliases key password. String <code>smallrye.config.source.keystore.\"name\".aliases.\"key\".handler</code>An Optional aliases key secret keys handler. String"},{"location":"config-sources/locations/","title":"Locations","text":"<p>Additionally, to the default config locations specified by the  MicroProfile Config specification, SmallRye Config provides a way to scan additional locations for configuration properties files.</p> <p>The <code>smallrye.config.locations</code> configuration property accepts multiple locations separated by a comma <code>,</code> and each  ust represent a valid <code>URI</code>. The supported <code>URI</code> schemes are:</p> <ul> <li>file or directory (<code>file:</code>)</li> <li>classpath resource</li> <li>jar resource (<code>jar:</code>)</li> <li>http resource (<code>http:</code>)</li> </ul> <p>Each <code>URI</code> scheme loads all discovered resources in a <code>ConfigSource</code>. All loaded sources use the same ordinal of the  source that found the <code>smallrye.config.locations</code> configuration property. For instance, if <code>smallrye.config.locations</code>  is set as a system property, then all loaded sources have their ordinals set to <code>400</code> (system properties use <code>400</code> as their ordinal). The ordinal may be overridden directly in the resource by setting the <code>config_ordinal</code> property.  Sources are sorted first by their ordinal, then by location order, and finally by loading order.</p> <p>If a profile is active, and the <code>URI</code> represents a single resource (for instance a file), then resources that match  the active profile are also loaded. The profile resource name must follow the pattern: <code>{location}-{profile}</code>. A  profile resource is only loaded if the unprofiled resource is also available in the same location. This is to keep a  consistent loading order and pair all the resources together.</p> <p>Profile resources are not taken into account if the location is a directory since there is no reliable way to discover  which file is the main resource. Properties that use the profile prefix syntax <code>%profile.</code> will work as expected.</p> <p>All properties files from a directory</p> <pre><code># loads all files from a relative path\nsmallrye.config.locations=./src/main/resources/\n\n# loads all files from an absolute path\nsmallrye.config.locations=/user/local/config\n</code></pre> <p>For relative paths, the JVM <code>user.dir</code> property defines the current directory.</p> <p>A specific file</p> ./src/main/resources/additional.properties<pre><code>smallrye.config.locations=./src/main/resources/additional.properties\n</code></pre> <p>If a profile <code>dev</code> is active, and an <code>additional-dev.properties</code> file exists, this will also be loaded.</p> <p>All <code>additional.properties</code> files from the classpath</p> additional.properties<pre><code>smallrye.config.locations=additional.properties\n</code></pre> <p>If a profile <code>prod</code> is active, and an <code>additional-prod.properties</code> resources exists next to the <code>additional.properties</code>  resource, this will also be loaded.</p> <p>The <code>resources.properties</code> file from a specific jar</p> jar:file:///user/local/app/lib/resources-.jar!/resources.properties<pre><code>smallrye.config.locations=jar:file:///user/local/app/lib/resources-.jar!/resources.properties\n</code></pre> <p>If a profile <code>test</code> is active, and an <code>additional-test.properties</code> resource exists, this will also be loaded.</p> <p>The <code>config.properties</code> file from a web server</p> http://localhost:8080/config/config.properties<pre><code>smallrye.config.locations=http://localhost:8080/config/config.properties\n</code></pre>"},{"location":"config-sources/yaml/","title":"YAML Config Source","text":"<p>This Config Source allows to use a <code>yaml</code> file to load configuration values. The YAML Config Source loads the configuration from the following files:</p> <ol> <li>(<code>265</code>) <code>application.yaml|yml</code> in <code>config</code> folder, located in the current working directory</li> <li>(<code>255</code>) <code>application.yaml|yml</code> in the classpath</li> <li>(<code>110</code>) MicroProfile Config configuration file <code>META-INF/microprofile-config.yaml|yml</code> in the classpath</li> </ol> <p>The following dependency is required in the classpath to use the YAML Config Source:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.config&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-config-source-yaml&lt;/artifactId&gt;\n    &lt;version&gt;3.13.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"config-sources/zookeeper/","title":"ZooKeeper Config Source","text":"<p>This Config Source allows using Apache ZooKeeper to load configuration  values.</p> <p>The following dependency is required in the classpath to use the ZooKeeper Config Source:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.config&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-config-source-zookeeper&lt;/artifactId&gt;\n    &lt;version&gt;3.13.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>It also requires to set up additional configuration properties to identify the ZooKeeper instance:</p> <pre><code>io.smallrye.configsource.zookeeper.url=localhost:2181\nio.smallrye.configsource.zookeeper.applicationId=applicationId\n</code></pre> <p>The ZooKeeper Config Source will look for configuration values in a ZooKeeper instance running in the url set in  <code>io.smallrye.configsource.zookeeper.url</code> and in the znodes available in <code>/applicationId/</code>.</p> <p>This Config Source has an ordinal of <code>150</code>.</p>"},{"location":"converters/custom/","title":"Custom <code>Converter</code>","text":"<p>It is possible to create a custom <code>Converter</code> type as specified in  MicroProfile Config.</p> <p>A custom <code>Converter</code> requires an implementation of <code>org.eclipse.microprofile.config.spi.Converter</code>. Each implementation  requires registration via the <code>ServiceLoader</code> mechanism in the  <code>META-INF/services/org.eclipse.microprofile.config.spi.Converter</code> file. Consider:</p> <pre><code>package org.acme.config;\n\npublic class CustomValue {\n\n    private final int number;\n\n    public CustomValue(int number) {\n        this.number = number;\n    }\n\n    public int getNumber() {\n        return number;\n    }\n}\n</code></pre> <p>The corresponding converter can look like:</p> <pre><code>package org.acme.config;\n\nimport org.eclipse.microprofile.config.spi.Converter;\n\npublic class CustomValueConverter implements Converter&lt;CustomValue&gt; {\n\n    @Override\n    public CustomValue convert(String value) {\n        return new CustomValue(Integer.parseInt(value));\n    }\n}\n</code></pre> <p>And registration in:</p> META-INF/services/org.eclipse.microprofile.config.spi.Converter<pre><code>org.acme.config.CustomValue\n</code></pre> <p>Warning</p> <p>The custom <code>Converter</code> class must be <code>public</code>, must have a <code>public</code> constructor with no arguments, and must not be  abstract.</p> <p>The <code>CustomValueConverter</code> converts the configuration value to the <code>CustomValue</code> type automatically.</p> <pre><code>Config config = ConfigProvider.getConfig();\nCustomValue value = config.getValue(\"custom.value\", CustomValue.class);\n</code></pre> <p>The <code>jakarta.annotation.Priority</code> annotation overrides the <code>Converter</code> priority and change converters precedence to fine  tune the execution order. By default, if no <code>@Priority</code> is specified by the <code>Converter</code>, the converter is registered  with a priority of <code>100</code>. Consider:</p> <pre><code>package org.acme.config;\n\nimport jakarta.annotation.Priority;\nimport org.eclipse.microprofile.config.spi.Converter;\n\n@Priority(150)\npublic class SecretConverter implements Converter&lt;CustomValue&gt; {\n\n    @Override\n    public CustomValue convert(String value) {\n        final int secretNumber;\n        if (value.startsFrom(\"OBF:\")) {\n            secretNumber = Integer.parseInt(SecretDecoder.decode(value));\n        } else {\n            secretNumber = Integer.parseInt(value);\n        }\n\n        return new CustomValue(secretNumber);\n    }\n}\n</code></pre> <p>Two <code>Converter</code>s, (<code>CustomValueConverter</code> and <code>SecretConverter</code>) can convert the same type <code>CustomValue</code>. Since  <code>SecretConverter</code> has a priority of <code>150</code>, it will be used instead of a <code>CustomValueConverter</code> which has a default  priority of <code>100</code> (no annotation).</p>"},{"location":"extensions/config-events/","title":"Config Events","text":"<p>The Config Events extension allows you to fire change events on Config Sources.</p>"},{"location":"extensions/config-events/#usage","title":"Usage","text":"<p>To use the Config Events, add the following to your Maven <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.config&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-config-events&lt;/artifactId&gt;\n    &lt;version&gt;3.13.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"extensions/config-events/#events","title":"Events","text":"<p>The CDI Event is a <code>ChangeEvent</code> and contains the following fields:</p> <ul> <li>String key</li> <li>Optional\\ oldValue <li>String newValue</li> <li>Type type</li> <li>String fromSource</li> <p>The <code>ChangeEvent</code> can be of any of the following types:</p> <ul> <li>NEW - When you create a new key and value (i.e. the key does not exist anywhere in any config source)</li> <li>UPDATE - When you update a value of an existing key (i.e. the key and value exist somewhere in a config source)</li> <li>REMOVE - When you remove the value from the source (and that changed the overall config)</li> </ul>"},{"location":"extensions/config-events/#observing-events","title":"Observing Events","text":"<p>You can listen to all or some of these events, filtering by <code>type</code> and/or <code>key</code> and/or <code>source</code>, example:</p> <pre><code>// Getting all config event\npublic void all(@Observes ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"ALL: Received a config change event: {0}\", changeEvent);\n}\n\n// Get only new values\npublic void newValue(@Observes @TypeFilter(Type.NEW) ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"NEW: Received a config change event: {0}\", changeEvent);\n}\n\n// Get only override values\npublic void overrideValue(@Observes @TypeFilter(Type.UPDATE) ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"UPDATE: Received a config change event: {0}\", changeEvent);\n}\n\n// Get only revert values\npublic void revertValue(@Observes @TypeFilter(Type.REMOVE) ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"REMOVE: Received a config change event: {0}\", changeEvent);\n}\n\n// Getting all config event when key is some.key\npublic void allForKey(@Observes @KeyFilter(\"some.key\") ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"ALL for key [some.key]: Received a config change event: {0}\", changeEvent);\n}\n\n// Getting all config event when key is some.key for new events\npublic void newForKey(@Observes @TypeFilter(Type.NEW) @KeyFilter(\"some.key\") ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"NEW for key [some.key]: Received a config change event: {0}\", changeEvent);\n}\n\n// Getting all config event when key is some.key for override events\npublic void overrideForKey(@Observes @TypeFilter(Type.UPDATE) @KeyFilter(\"some.key\") ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"UPDATE for key [some.key]: Received a config change event: {0}\", changeEvent);\n}\n\n// Getting all config event when key is some.key for revert events\npublic void revertForKey(@Observes @TypeFilter(Type.REMOVE) @KeyFilter(\"some.key\") ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"REMOVE for key [some.key]: Received a config change event: {0}\", changeEvent);\n}\n\n// Getting all config events for a certain source\npublic void allForSource(@Observes @SourceFilter(\"MemoryConfigSource\") ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"ALL for source [MemoryConfigSource]: Received a config change event: {0}\", changeEvent);\n}\n\n// Getting all config events for a certain source\npublic void allForSourceAndKey(@Observes @SourceFilter(\"MemoryConfigSource\") @KeyFilter(\"some.key\")  ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"ALL for source [MemoryConfigSource] and for key [some.key]: Received a config change event: {0}\", changeEvent);\n}\n\n// Getting all config events for a certain source\npublic void overrideForSourceAndKey(@Observes @TypeFilter(Type.UPDATE) @SourceFilter(\"MemoryConfigSource\") @KeyFilter(\"some.key\")  ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"UPDATE for source [MemoryConfigSource] and for key [some.key]: Received a config change event: {0}\", changeEvent);\n}\n</code></pre> <p>Note: You can filter by including the <code>@TypeFilter</code> and/or the <code>@KeyFilter</code> and/or the <code>@SourceFilter</code>.</p>"},{"location":"extensions/config-events/#pattern-matching-on-field","title":"Pattern matching on field.","text":"<p>You might want to listen for fields that match a certain regex.</p> <p>Example, listen to all keys that starts with <code>some.</code>:</p> <pre><code>@RegexFilter(\"^some\\\\..+\")\npublic void allForPatternMatchOnKey(@Observes ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"Pattern match on key: Received a config change event: {0}\", changeEvent);\n}\n</code></pre> <p>By default, it will match on <code>key</code>, however you also listen on another field, for example, listen to all <code>oldValue</code>  that starts with <code>some.</code>:</p> <pre><code>@RegexFilter(onField = Field.oldValue, value = \"^some\\\\..+\")\npublic void allForPatternMatchOnOldValue(@Observes ChangeEvent changeEvent){\n    log.log(Level.SEVERE, \"Pattern match on old value: Received a config change event: {0}\", changeEvent);\n}\n</code></pre> <p>You can Match on the following fields of the <code>ChangeEvent</code> object:</p> <ul> <li>key</li> <li>oldValue</li> <li>newValue</li> <li>fromSource</li> </ul>"},{"location":"extensions/config-events/#implementing-events-in-a-configsource","title":"Implementing Events in a ConfigSource","text":"<p>The <code>ChangeEventNotifier</code> allows you to detect changes and fire the appropriate events.</p> <p>To use it in your own source:</p> <ul> <li>Get a snapshot of the properties before the change.</li> <li>Get a snapshot of the properties after the change.</li> <li>Call <code>detectChangesAndFire</code> method:</li> </ul> <p>Example:</p> <pre><code>Map&lt;String,String&gt; before = new HashMap&lt;&gt;(configSource.getProperties());\nmemoryConfigSource.getProperties().remove(key);\nMap&lt;String,String&gt; after = new HashMap&lt;&gt;(configSource.getProperties());\nChangeEventNotifier.getInstance().detectChangesAndFire(before, after,configSource.getName());\n</code></pre> <p>or if you know the change and do not need detection:</p> <pre><code>configSource.getProperties().remove(key);\nChangeEventNotifier.getInstance().fire(new ChangeEvent(Type.REMOVE,key,getOptionalOldValue(oldValue),null,configSource.getName()));\n</code></pre>"},{"location":"extensions/config-source-injection/","title":"Config Source Injection","text":"<p>The Config Source Injection extension allows you to use CDI injection to inject a ConfigSource by name in your CDI  aware beans, or by looking it up programatically in the CDI <code>BeanManager</code>.</p>"},{"location":"extensions/config-source-injection/#usage","title":"Usage","text":"<p>To use the Config Source Injection, add the following to your Maven <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.config&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-config-source-injection&lt;/artifactId&gt;\n    &lt;version&gt;3.13.2-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"extensions/config-source-injection/#injecting-sources","title":"Injecting Sources","text":"<p>You can inject a <code>ConfigSource</code> by referencing it by name:</p> <pre><code>@Inject\n@Name(\"MemoryConfigSource\")\nprivate ConfigSource memoryConfigSource;\n\n@Inject\n@Name(\"SysPropConfigSource\")\nprivate ConfigSource systemPropertiesConfigSource;\n</code></pre> <p>You can also get a Map of all config sources. The map key holds the <code>ConfigSource</code> name and the map value the  <code>ConfigSource</code>:</p> <pre><code>@Inject\n@ConfigSourceMap\nprivate Map&lt;String,ConfigSource&gt; configSourceMap;\n</code></pre>"},{"location":"extensions/fallback/","title":"Fallback","text":"<p>The <code>io.smallrye.config.FallbackConfigSourceInterceptor</code> allows to fall back to another configuration name, by  providing a transformation function or just a simple key value map.</p> <p>When a configuration name does not exist, there might be another configuration name that the config can fall back to provide the same expected behavior. The fallback function is only applied if the original resolved configuration name is not found and resolved to the fallback name.</p> <pre><code>package org.acme.config;\n\nimport io.smallrye.config.FallbackConfigSourceInterceptor;\n\npublic class MicroProfileConfigFallbackInterceptor extends FallbackConfigSourceInterceptor {\n    public MicroProfileConfigFallbackInterceptor() {\n        super(name -&gt; name.startsWith(\"mp.config\") ?\n                      name.replaceAll(\"mp\\\\.config\", \"smallrye.config\") :\n                      name);\n    }\n}\n</code></pre> <p>And registration in:</p> META-INF/services/io.smallrye.config.ConfigSourceInterceptor<pre><code>org.acme.config.MicroProfileConfigFallbackInterceptor\n</code></pre> <p>The <code>MicroProfileConfigFallbackInterceptor</code> can fallback configuration names in the <code>mp.config</code> namespace to the <code>smallrye.config</code> namespace.</p> <p>Example</p> application.properties<pre><code>mp.config.profile=test\nsmallrye.config.profile=prod\n</code></pre> <p>A lookup to <code>mp.config.profile</code> returns the value <code>test</code>.</p> application.properties<pre><code>smallrye.config.profile=prod\n</code></pre> <p>A lookup to <code>mp.config.profile</code> returns the value <code>prod</code>. The config is not able to find a value for  <code>mp.config.profile</code>, so the interceptor fallbacks and lookups the value of <code>smallrye.config.profile</code>.</p>"},{"location":"extensions/interceptors/","title":"Interceptors","text":"<p>SmallRye Config provides an interceptor chain that hooks into the configuration values resolution. This is useful to  implement features like Profiles , Property Expressions, or just  logging to find out where the config value was loaded from.</p> <p>An interceptor can be created by implementing the  ConfigSourceInterceptor interface.</p> <p>An interceptor requires an implementation of <code>io.smallrye.config.ConfigSourceInterceptor</code>. Each implementation requires  registration via the <code>ServiceLoader</code> mechanism in the <code>META-INF/services/io.smallrye.config.ConfigSourceInterceptor</code>  file. Alternatively, interceptors may be registered via the Programmatic API in  <code>SmallRyeConfigBuilder#withInterceptors</code>.</p> <p>The <code>io.smallrye.config.ConfigSourceInterceptor</code> is able to intercept the resolution of a configuration name with the  method <code>ConfigValue getValue(ConfigSourceInterceptorContext context, String name)</code>. The <code>ConfigSourceInterceptorContext</code> is used to proceed with the interceptor chain. The chain can be short-circuited by returning an instance of  <code>io.smallrye.config.ConfigValue</code>. The <code>ConfigValue</code> objects hold information about the key name, value, config source  origin and ordinal.</p> <p>Info</p> <p>The interceptor chain is applied before any conversion is performed on the configuration value.</p> <pre><code>package org.acme.config;\n\nimport static io.smallrye.config.SecretKeys.doLocked;\n\nimport jakarta.annotation.Priority;\n\nimport io.smallrye.config.ConfigSourceInterceptor;\nimport io.smallrye.config._private.ConfigLogging;\n\n@Priority(Priorities.LIBRARY + 200)\npublic class LoggingConfigSourceInterceptor implements ConfigSourceInterceptor {\n    private static final long serialVersionUID = 367246512037404779L;\n\n    @Override\n    public ConfigValue getValue(final ConfigSourceInterceptorContext context, final String name) {\n        ConfigValue configValue = doLocked(() -&gt; context.proceed(name));\n        if (configValue != null) {\n            ConfigLogging.log.lookup(configValue.getName(), configValue.getLocation(), configValue.getValue());\n        } else {\n            ConfigLogging.log.notFound(name);\n        }\n        return configValue;\n    }\n}\n</code></pre> <p>And registration in:</p> META-INF/services/io.smallrye.config.ConfigSourceInterceptor<pre><code>org.acme.config.LoggingConfigSourceInterceptor\n</code></pre> <p>The <code>LoggingConfigSourceInterceptor</code> logs looks up configuration names in the provided logging platform. The log  information includes config name and value, the config source origin and location if exists.</p> <p>Interceptors may also be created with an implementation of <code>io.smallrye.config.ConfigSourceInterceptorFactory</code>. Each  implementation requires registration via the <code>ServiceLoader</code> mechanism in the  <code>META-INF/services/io.smallrye.config.ConfigSourceInterceptorFactory</code> file. Alternatively, interceptors factories may  be registered via the Programmatic API in <code>SmallRyeConfigBuilder#withInterceptorFactories</code>.</p> <p>The <code>ConfigSourceInterceptorFactory</code> can initialize an interceptor with access to the current chain  (so it can be used to configure the interceptor and retrieve configuration values) and set the priority.</p> <p>A <code>ConfigSourceInterceptor</code> implementation class can specify a priority by way of the standard  <code>jakarta.annotation.Priority</code> annotation. If no priority is explicitly assigned, the default priority value of  <code>io.smallrye.config.Priorities.APPLICATION</code> is assumed. If multiple interceptors are registered with the same priority,  then their execution order may be non-deterministic.</p> <p>A collection of built-in priority constants can be found in <code>io.smallrye.config.Priorities</code>. It is recommended to  use <code>io.smallrye.config.Priorities.APPLICATION</code> as a baseline for user defined interceptors.</p>"},{"location":"extensions/logging/","title":"Logging","text":""},{"location":"extensions/logging/#loggingconfigsourceinterceptor","title":"LoggingConfigSourceInterceptor","text":"<p>The <code>io.smallrye.config.LoggingConfigSourceInterceptor</code> logs lookups of configuration names in the provided logging  platform. The log information includes config name and value, the config source origin and location if it exists.</p> <p>The log is done as <code>debug</code>, so the debug threshold must be set to <code>debug</code> for the <code>io.smallrye.config</code> appender to display the logs.</p> <p>This requires registration via the <code>ServiceLoader</code> mechanism in the <code>META-INF/services/io.smallrye.config.ConfigSourceInterceptorFactory</code> file of the  <code>io.smallrye.config.LoggingConfigSourceInterceptor</code> interceptor.</p>"},{"location":"extensions/relocate/","title":"Relocate","text":"<p>The <code>io.smallrye.config.RelocateConfigSourceInterceptor</code> allows to relocate a configuration name to another name, by  providing a transformation function or just a simple key value map.</p> <p>When a configuration key is renamed, lookup needs to happen on the new name, but also on the old name if the config sources are not updated yet. The relocation function gives priority to the new resolved configuration name or resolves to the old name if no value is found under the new relocation name.</p> <pre><code>package org.acme.config;\n\nimport io.smallrye.config.RelocateConfigSourceInterceptor;\n\npublic class MicroProfileConfigRelocateInterceptor extends RelocateConfigSourceInterceptor {\n    public MicroProfileConfigRelocateInterceptor() {\n        super(name -&gt; name.startsWith(\"mp.config\") ?\n                      name.replaceAll(\"mp\\\\.config\", \"smallrye.config\") :\n                      name);\n    }\n}\n</code></pre> <p>And registration in:</p> META-INF/services/io.smallrye.config.ConfigSourceInterceptor<pre><code>org.acme.config.MicroProfileConfigRelocateInterceptor\n</code></pre> <p>The <code>MicroProfileConfigRelocateInterceptor</code> can relocate configuration names in the <code>mp.config</code> namespace to the <code>smallrye.config</code> namespace.</p> <p>Example</p> application.properties<pre><code>mp.config.profile=test\nsmallrye.config.profile=prod\n</code></pre> <p>A lookup to <code>mp.config.profile</code> returns the value <code>prod</code>. The config finds a valid value in the relocated name  <code>smallrye.config.profile</code>, so the interceptor will use this value instead of the one in <code>mp.config.profile</code>.</p>"}]}